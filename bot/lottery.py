import uuid
from datetime import datetime
from enum import Enum
from zoneinfo import ZoneInfo

from telegram import InlineKeyboardMarkup, InlineKeyboardButton, Update
from telegram.constants import ChatMemberStatus
from telegram.ext import ConversationHandler, CommandHandler, CallbackQueryHandler, MessageHandler, \
    filters, ContextTypes

import re

from bot.randomiser import Randomiser
from services.utils import encode_payload
from services.firebase import FirebaseClient



def parse_date(date_str: str) -> datetime | None:
    """
    ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµÑ‚ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ² datetime, ĞµÑĞ»Ğ¸ Ğ¾Ğ½Ğ° ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñƒ 'dd.mm.yyyy hh:mm',
    Ğ¸Ğ½Ğ°Ñ‡Ğµ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ None.
    """
    try:
        date = datetime.strptime(date_str, "%d.%m.%Y %H:%M")
        moscow_time = date.replace(tzinfo=ZoneInfo("Europe/Moscow"))
        return moscow_time.astimezone(ZoneInfo("UTC"))
    except ValueError:
        return None

class Lottery:
    class NewLotteryState(Enum):
        READY = 0
        TEXT = 1
        NUM_WINNERS = 2
        MODE = 3
        DATE = 4
        COUNT = 5
        PUBLISHER = 6


    def __init__(self, firebase: FirebaseClient, randomiser: Randomiser):
        self.firebase_db = firebase
        self.randomise_job = randomiser
        self.mode_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Ğ—Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ", callback_data="mode_date")],
            [InlineKeyboardButton("Ğ—Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ Ñ‡Ğ¸ÑĞ»Ñƒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²", callback_data="mode_count")],
            [InlineKeyboardButton("ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_data")]
        ])
        self.back_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_data")]
            ])

        self.lottery_text_guide = "ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹ÑˆĞ° Ğ²Ğ¼ĞµÑÑ‚Ğµ ÑĞ¾ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ¿Ñ€Ğ¸ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸."
        self.lottery_num_winners_guide = "ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹."
        self.lottery_mode_guide = "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹ÑˆĞ°."
        self.lottery_date_guide = "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹ÑˆĞ° Ğ¿Ğ¾ ĞœĞ¡Ğš. ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 01.01.2023 00:00"
        self.lottery_count_guide = "ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ², Ğ¿Ñ€Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¸ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹Ñˆ Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ½Ñ‡Ğ¸Ğ²Ğ°Ñ‚ÑŒÑÑ."
        self.lottery_publisher_guide = "ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ°Ğ½Ğ°Ğ», ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¾Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµÑ‚ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹ÑˆĞ°."

    async def get_publisher_channels_keyboard(self, update: Update,
                                        context: ContextTypes.DEFAULT_TYPE) -> InlineKeyboardMarkup:
        """
        Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ñ‹ Ğ² ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğµ Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€Ğ°.
        """
        channels = await self.firebase_db.get_user_channels(update.effective_user.id)
        keyboard = []
        for i, channel in enumerate(channels):
            match = re.search(r'>([^<]+)<', channel["username"])
            title = match.group(1) if match else "ĞšĞ°Ğ½Ğ°Ğ»"
            button = InlineKeyboardButton(text=title, callback_data=f"{channel['chat_id']}")
            keyboard.append([button])
        keyboard.append([InlineKeyboardButton("ĞĞ°Ğ·Ğ°Ğ´", callback_data="back_data")])
        return InlineKeyboardMarkup(keyboard)

    def get_handler(self):
        return ConversationHandler(
            entry_points=[
                CommandHandler("new_lot", self.new_lot),
                MessageHandler(filters.TEXT & filters.Regex("^ğŸ‰ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹Ñˆ$"), self.new_lot),
            ],
            states={
                self.NewLotteryState.READY.value: [
                    CallbackQueryHandler(self.setup_lot)
                ],
                self.NewLotteryState.TEXT.value: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.lottery_text),
                ],
                self.NewLotteryState.NUM_WINNERS.value: [
                    CallbackQueryHandler(self.lottery_num_winners),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.lottery_num_winners),
                ],
                self.NewLotteryState.MODE.value: [
                    CallbackQueryHandler(self.lottery_mode)
                ],
                self.NewLotteryState.DATE.value: [
                    CallbackQueryHandler(self.lottery_date),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.lottery_date),
                ],
                self.NewLotteryState.COUNT.value: [
                    CallbackQueryHandler(self.lottery_count),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.lottery_count),
                ],
                self.NewLotteryState.PUBLISHER.value: [
                    CallbackQueryHandler(self.lottery_publisher),
                ]
            },
            fallbacks=[],
        )

    async def create_channel_list_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾", callback_data="ready")]])
        user_id = update.effective_user.id
        channels = await self.firebase_db.get_user_channels(user_id)
        message = await update.message.reply_text(
            "Ğ”Ğ»Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ±Ğ¾Ñ‚Ğ° ĞºĞ°Ğº Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° Ğ²Ğ¾ Ğ²ÑĞµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹, "
            "ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹ÑˆĞ°.\n\nĞ’Ğ°ÑˆĞ¸ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… ĞµÑÑ‚ÑŒ Ğ±Ğ¾Ñ‚:\n" +
            "\n".join(f'{c["username"]} ({c["status"]})' for c in sorted(channels, key=lambda x: x["username"])),
            reply_markup=keyboard,
            parse_mode="HTML",
            disable_web_page_preview=True
        )
        await self.firebase_db.update(f"users/{user_id}", {"added_channels_message": message.message_id})

    async def update_channel_list_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user = update.my_chat_member.from_user
        user_id = user.id
        channels = await self.firebase_db.get_user_channels(user_id)
        added_msg_id = (await self.firebase_db.read(f"users/{user_id}/added_channels_message")) or 0
        keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ", callback_data="ready")]])
        await context.bot.edit_message_text(
            chat_id=user_id,
            message_id=added_msg_id,
            text="Ğ”Ğ»Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ±Ğ¾Ñ‚Ğ° ĞºĞ°Ğº Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° Ğ²Ğ¾ Ğ²ÑĞµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹, "
                 "ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸ Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹ÑˆĞ°.\n\nĞ’Ğ°ÑˆĞ¸ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… ĞµÑÑ‚ÑŒ Ğ±Ğ¾Ñ‚:\n" +
                 "\n".join(f'{c["username"]} ({c["status"]})' for c in sorted(channels, key=lambda x: x["username"])),
            parse_mode="HTML",
            reply_markup=keyboard,
            disable_web_page_preview=True
        )

    async def new_lot(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        context.user_data["lottery_id"] = str(uuid.uuid4())[:8]
        await self.create_channel_list_message(update, context)
        return self.NewLotteryState.READY.value

    async def setup_lot(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        user_id = update.effective_user.id
        channels = await self.firebase_db.get_user_channels(user_id)

        if not channels:
            await query.answer("Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ±Ğ¾Ñ‚Ğ° ĞºĞ°Ğº Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ² Ğ¾Ğ´Ğ¸Ğ½ ĞºĞ°Ğ½Ğ°Ğ»!", show_alert=True)
            return self.NewLotteryState.READY.value
        if not all(c["status"] == ChatMemberStatus.ADMINISTRATOR for c in channels):
            await query.answer("Ğ‘Ğ¾Ñ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼ Ğ²Ğ¾ Ğ²ÑĞµÑ… ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ñ…, Ğ³Ğ´Ğµ Ğ¾Ğ½ ĞµÑÑ‚ÑŒ!", show_alert=True)
            return self.NewLotteryState.READY.value

        await query.edit_message_text(self.lottery_text_guide)
        return self.NewLotteryState.TEXT.value

    async def lottery_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        description = update.message
        await self.firebase_db.write(f"lotteries/{update.effective_user.id}/{context.user_data['lottery_id']}", {
            "description": description.text
        })
        await update.message.reply_text(self.lottery_num_winners_guide,
                                        reply_markup=self.back_keyboard)
        return self.NewLotteryState.NUM_WINNERS.value


    async def lottery_num_winners(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        if update.callback_query:
            query = update.callback_query
            if query.data == "back_data":
                await query.edit_message_text(self.lottery_text_guide)
                return self.NewLotteryState.TEXT.value
            return self.NewLotteryState.NUM_WINNERS.value

        num_winners = update.message.text
        if num_winners.isdigit():
            await self.firebase_db.update(f"lotteries/{update.effective_user.id}/{context.user_data['lottery_id']}", {
                "num_winners": int(num_winners)
            })
            await update.message.reply_text(self.lottery_mode_guide, reply_markup=self.mode_keyboard)
            return self.NewLotteryState.MODE.value

        await update.message.reply_text("ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¿Ğ¾Ğ±ĞµĞ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ (Ñ†ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾).",
                                        reply_markup=self.back_keyboard)
        return self.NewLotteryState.NUM_WINNERS.value


    async def lottery_mode(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        query = update.callback_query

        if query.data == "mode_date":
            await query.edit_message_text(self.lottery_date_guide, reply_markup=self.back_keyboard)
            return self.NewLotteryState.DATE.value
        elif query.data == "mode_count":
            await query.edit_message_text(self.lottery_count_guide,
                                          reply_markup=self.back_keyboard)
            return self.NewLotteryState.COUNT.value

        await query.edit_message_text(self.lottery_num_winners_guide,
                                      reply_markup=self.back_keyboard)
        return self.NewLotteryState.NUM_WINNERS.value


    async def lottery_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        if update.callback_query:
            query = update.callback_query
            if query.data == "back_data":
                await query.edit_message_text(self.lottery_mode_guide,
                                              reply_markup=self.mode_keyboard)
                return self.NewLotteryState.MODE.value
            return self.NewLotteryState.COUNT.value

        count_str = update.message.text
        publisher_keyboard = await self.get_publisher_channels_keyboard(update, context)
        if count_str.isdigit():
            await self.firebase_db.update(f"lotteries/{update.effective_user.id}/{context.user_data['lottery_id']}", {
                "max_count": int(count_str),
            })
            await update.message.reply_text(self.lottery_publisher_guide,
                                            reply_markup=publisher_keyboard)
            return self.NewLotteryState.PUBLISHER.value

        await update.message.reply_text("ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² (Ñ†ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾).",
                                        reply_markup=self.back_keyboard)
        return self.NewLotteryState.COUNT.value


    async def lottery_date(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        if update.callback_query:
            query = update.callback_query
            if query.data == "back_data":
                await query.edit_message_text(self.lottery_mode_guide,
                                              reply_markup=self.mode_keyboard)
                return self.NewLotteryState.MODE.value
            return self.NewLotteryState.DATE.value

        date_str = update.message.text
        utc_time = parse_date(date_str)


        await self.firebase_db.update(f"lotteries/{update.effective_user.id}/{context.user_data['lottery_id']}", {
            "until_date": utc_time.isoformat()
        })

        publisher_keyboard = await self.get_publisher_channels_keyboard(update, context)
        if utc_time:
            await update.message.reply_text(self.lottery_publisher_guide,
                                            reply_markup=publisher_keyboard)
            return self.NewLotteryState.PUBLISHER.value

        await update.message.reply_text(
            "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ‚ÑŒ Ğ´Ğ°Ñ‚Ñƒ." + self.lottery_date_guide, reply_markup=self.back_keyboard)
        return self.NewLotteryState.DATE.value

    async def lottery_publisher(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        query = update.callback_query

        if query.data == "back_data":
            await query.edit_message_text(self.lottery_mode_guide,
                                          reply_markup=self.mode_keyboard)
            return self.NewLotteryState.MODE.value

        await self.firebase_db.update(f"lotteries/{update.effective_user.id}/{context.user_data['lottery_id']}", {
            "publisher_chat_id": int(query.data)
        })
        await self.publish_lottery(update, context)
        lottery_url = await self.generate_invite_link(update, context)
        await context.bot.send_message(chat_id=query.from_user.id, text="ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹Ñˆ ÑĞ¾Ğ·Ğ´Ğ°Ğ½!\n"
                                                                        "Ğ¡ÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° Ñ€Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹Ñˆ: " + lottery_url)
        return ConversationHandler.END

    async def publish_lottery(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        lottery_id = context.user_data["lottery_id"]
        chat_id = await self.firebase_db.read(
            f"lotteries/{update.effective_user.id}/{lottery_id}/publisher_chat_id")
        num_winners = await self.firebase_db.read(
            f"lotteries/{update.effective_user.id}/{lottery_id}/num_winners"
        )
        date = await self.firebase_db.read(
            f"lotteries/{update.effective_user.id}/{lottery_id}/until_date")
        if date:
            date = datetime.fromisoformat(date)
            context.job_queue.run_once(self.randomise_job.generate_result, when=date, data=
            {
                "owner_id": update.effective_user.id,
                "lottery_id": lottery_id,
                "publisher_chat_id": chat_id,
                "num_winners": num_winners
            })
            return
        max_count = await self.firebase_db.read(
            f"lotteries/{update.effective_user.id}/{lottery_id}/max_count"
        )
        context.job_queue.run_repeating(self.randomise_job.check_lottery_count, interval=10, first=0, data=
        {
            "owner_id": update.effective_user.id,
            "lottery_id": lottery_id,
            "goal_participants": max_count,
            "publisher_chat_id": chat_id,
            "num_winners": num_winners
        })


    async def generate_invite_link(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
        bot_username = "t_ad_manager_bot"

        lottery_id = context.user_data["lottery_id"]
        user_id = update.effective_user.id
        encoded_payload = encode_payload(user_id, lottery_id)

        url = f"https://t.me/{bot_username}?start={encoded_payload}"
        return url